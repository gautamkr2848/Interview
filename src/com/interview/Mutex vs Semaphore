Mutex & Semaphore

As per operating system terminology, mutexes and semaphores are kernel resources that are used for synchronization

    Atomicity - Atomicity is unbreakability, i.e. an uninterrupted operation
                eg - printer

    Critical Section - When more than one processes access the same resource i.e known as the critical section. The
    critical section contains shared variables or resources which are needed to be synchronized to maintain the
    consistency of data variables.

Using Mutex:

A mutex provides mutual exclusion, either producer or consumer can have the key (mutex) and proceed with their work.
As long as the buffer is filled by the producer, the consumer needs to wait, and vice versa.

At any point of time, only one thread can work with the entire buffer. The concept can be generalized using semaphore.

Using Semaphore:

A semaphore is a generalized mutex. In line of a single buffer, we can split the 4 KB buffer into four 1 KB buffers
(identical resources). A semaphore can be associated with these four buffers. The consumer and producer can work on
different buffers at the same time.

Misconception:

A mutex is a binary semaphore. But it is not! The purpose of mutex and semaphore are different. Maybe, due to similarity
in their implementation a mutex would be referred to as a binary semaphore.

Strictly speaking, a mutex is a locking mechanism used to synchronize access to a resource. Only one task  can acquire
the mutex. It means there is ownership associated with a mutex, and only the owner can release the lock (mutex).

Semaphore is signaling mechanism (“I am done, you can carry on” kind of signal).

A programmer can prefer mutex rather than creating a semaphore with count 1.


General Questions:

1. Can a thread acquire more than one lock (Mutex)?

Yes, it is possible that a thread is in need of more than one resource, hence the locks. If any lock is not available
the thread will wait (block) on the lock.

2. Can a mutex be locked more than once?

A mutex is a lock. Only one state (locked/unlocked) is associated with it. However, a recursive mutex can be locked
more than once (POSIX compliant systems), in which a count is associated with it, yet retains only one state
(locked/unlocked). The programmer must unlock the mutex as many number times as it was locked.

If a thread that had already locked a mutex, tries to lock the mutex again, it will enter into the waiting
list of that mutex, which results in a deadlock.