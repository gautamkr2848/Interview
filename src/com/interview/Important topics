1. Content Delivery Network
    A content delivery network (CDN) refers to a distributed group of servers
    which work together to provide fast delivery of Internet content.
    Benefits of CDN :
        a. Improving website load times
        b. Reducing bandwidth costs
        c. Increasing content availability and redundancy
        d. Improving website security

    In order to improve speed and connectivity, a CDN will place servers at the exchange
    points between different networks.

2. Distributed Cache    =>  Redis
3. Pub/Sub Model
    The Publish/Subscribe pattern, also known as pub/sub, is an architectural design pattern
    that provides a framework for exchanging messages between publishers and subscribers. This
    pattern involves the publisher and the subscriber relying on a message broker that relays
    messages from the publisher to the subscribers. The host (publisher) publishes messages (events)
    to a channel that subscribers can then sign up to.

4. Event Driven Architecture
    Two microservices communicate with each other based on event bus.
    An e-commerce application that uses this approach would work as follows:
        a. The Order Service creates an Order in a pending state and publishes an OrderCreated event.
        b. The Customer Service receives the event and attempts to reserve credit for that Order.
            It then publishes either a Credit Reserved event or a CreditLimitExceeded event.
        c. The Order Service receives the event from the Customer Service and changes the state of
            the order to either approved or cancelled

5. Service Discovery    =>  Eureka


6. Database Sharding
    Example of horizontal scaling
        User table - Storing all the users
        After Sharding -
            Stores  A-I in user1 table
                    J-S in user2 table
                    T-Z in user3 table

7. Load Balancing   =>  Ribbon
    Load balancing refers to the process of distributing a set of tasks over a set of resources,
    with the aim of making their overall processing more efficient.
    Algorithms :
        a. Round Robin
        b. Hash
        c. Consistent Hash
        d. Least Connection

    Benefits:
        a. Reduce Downtime
        b. Increase Performance
        c. Scalability
        d. Flexibility

8. Consistent Hashing
    https://medium.com/@sandeep4.verma/consistent-hashing-8eea3fb4a598

9. Scaling
    Vertical => Buying a bigger system
    Horizontal => Increasing number of instances

12. Apache Kafka

13. Zuul    =>  API Gateway
    Separate Out
        Authentication
        Authorization
        SSL Certification
        Cache
        Static Content
        Also decides where to route a request based on url(ms1 or ms2)

14. Executor Service
     Java provides its own multi-threading framework called the Java Executor Framework.
            1. SingleThreadExecutor
            2. FixedThreadPool(n)   =>  LinkedBlockingQueue
            3. CachedThreadPool     =>  SynchronousQueue
            4. ScheduledExecutor

15. Ideal Thread Pool Size
    CPU Oriented - no. of threads = no. of cores
    I/O Oriented - no. of threads = no. of cores * (1 + waitTime/CPUTime)

16. Functional Interface
    a. Functional interfaces are interfaces which represent some functionality. Can have only one abstract method.
    b. Lambda's are used to represent the instance of a functional interfaces
    c. @FunctionalInterface Annotation
        a. Runnable
        b. Callable
        c. Comparator
        d. public interface Predicate<T>{
                boolean test(T t);
        }
        e. public interface Consumer<T>{
                void accept(T t);
        }
        f. public interface Function<T>{
                T get();
        }
        g. public interface Supplier<T, R>{
                R apply(T t);
        }

16. Lambdas
    a. Functional Programming
    b. More redable and maintainable code
    c. Gives Parallel procesing

17. Resilience4J    =>  Fault Tolerance
    a. Retry
    b. Circuit Breaker
    c. Bulkhead
    d. Timer
    e. Rate Limiter

18. Map Struct  =>  Mapper

19.
